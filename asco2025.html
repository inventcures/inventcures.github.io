<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCO 2025 Clinical Trial Pipeline Dashboard</title>
    <meta name="description" content="Interactive dashboard visualizing clinical trials in progress from ASCO 2025.">
    
    <!-- External libraries -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #2c5aa0 0%, #4a6741 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 20px;
            background: linear-gradient(135deg, #0f4c75 0%, #3282b8 100%);
            color: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(15, 76, 117, 0.3);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 20px;
            opacity: 0.9;
        }

        .description {
            max-width: 800px;
            margin: 0 auto 20px;
            font-size: 1rem;
            line-height: 1.7;
        }

        .note {
            font-size: 0.9rem;
            opacity: 0.8;
            font-style: italic;
        }

        .note a {
            color: #64ffda;
            text-decoration: none;
            font-weight: 600;
            transition: color 0.3s ease;
        }

        .note a:hover {
            color: #80e5ff;
            text-decoration: underline;
        }

        .author-name {
            color: #ffd54f;
            font-weight: 600;
        }

        .homepage-link {
            position: absolute;
            top: 20px;
            left: 35px;
            color: #ffffff;
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .homepage-link:hover {
            color: #64ffda;
            transform: translateX(-2px);
        }

        .homepage-link::before {
            content: "‚Üê";
            font-size: 1.2rem;
            color: #64ffda;
        }

        .subtitle a {
            color: #64ffda;
            text-decoration: none;
            font-weight: 600;
            transition: color 0.3s ease;
        }

        .subtitle a:hover {
            color: #80e5ff;
            text-decoration: underline;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: nowrap;
            justify-content: center;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            overflow-x: auto;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex-shrink: 0;
            min-width: 120px;
        }

        .filter-group label {
            font-weight: 500;
            color: #333;
            font-size: 0.9rem;
        }

        .filter-select {
            padding: 6px 8px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 13px;
            min-width: 120px;
            transition: border-color 0.2s ease;
        }

        .filter-select:focus {
            outline: none;
            border-color: #667eea;
        }

        .main-content {
            display: flex;
            gap: 30px;
            margin-bottom: 40px;
        }

        .sidebar {
            min-width: 250px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            height: fit-content;
        }

        .cancer-type-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .cancer-type-item {
            padding: 12px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
            border: 2px solid transparent;
        }

        .cancer-type-item:hover {
            background: #e9ecef;
            transform: translateX(2px);
        }

        .cancer-type-item.active {
            background: #3282b8;
            color: white;
            border-color: #64ffda;
            font-weight: 500;
        }

        .chart-container {
            flex: 1;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
        }

        /* Floating Search Bar */
        .floating-search-bar {
            position: sticky;
            top: 20px;
            margin: 0 -40px 20px -40px;
            width: calc(100% + 80px);
            min-height: 120px;
            z-index: 1000;
            background: linear-gradient(135deg, #0f4c75 0%, #3282b8 100%);
            border-radius: 12px;
            padding: 24px 40px;
            box-shadow: 0 8px 32px rgba(15, 76, 117, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            display: none;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .floating-search-bar.show {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .floating-search-bar .search-input-container {
            margin-bottom: 12px;
            align-items: stretch;
        }

        .floating-search-bar #nl-query {
            font-size: 20px;
            padding: 30px 40px;
            min-height: 120px;
            flex: 4;
            min-width: 800px;
            width: 100%;
        }

        .floating-search-bar #nl-search-btn,
        .floating-search-bar #nl-clear-btn {
            padding: 14px 24px;
            font-size: 15px;
            min-height: 48px;
        }

        .floating-search-bar .search-status {
            margin-top: 8px;
            padding: 6px 12px;
            font-size: 12px;
            min-height: 16px;
            max-width: 600px;
            border-radius: 6px;
        }

        .floating-search-bar .suggested-queries {
            display: none; /* Hide suggestions in floating mode */
        }

        /* Close button for floating search */
        .floating-close-btn {
            position: absolute;
            top: 8px;
            right: 12px;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 18px;
            cursor: pointer;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .floating-close-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        #scatter-plot {
            width: 100%;
            height: 600px;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .tooltip-title {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 13px;
            color: #ffffff;
        }

        .tooltip-details div {
            margin-bottom: 4px;
            line-height: 1.4;
        }

        .abstract-preview {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #444;
            font-size: 11px;
            line-height: 1.3;
        }

        .tooltip-action {
            margin-top: 8px;
            font-style: italic;
            color: #ccc;
            font-size: 11px;
        }

        .llm-summary {
            margin-top: 8px;
            padding: 8px;
            background: rgba(100, 255, 218, 0.1);
            border: 1px solid rgba(100, 255, 218, 0.3);
            border-radius: 4px;
            font-size: 11px;
            line-height: 1.4;
        }

        .background-section {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 8px;
            margin-top: 40px;
        }

        .background-section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .background-section p {
            color: #666;
            line-height: 1.7;
        }

        .data-point {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .data-point:hover {
            stroke: #333;
            stroke-width: 2px;
            r: 8;
        }

        .axis-title {
            font-size: 12px;
            fill: #666;
        }

        .axis text {
            font-size: 11px;
            fill: #666;
        }

        .axis path,
        .axis line {
            fill: none;
            stroke: #ccc;
            shape-rendering: crispEdges;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }
            
            #scatter-plot {
                height: 400px;
            }
            
            .main-content {
                flex-direction: column;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
        }

        .phase-indicator {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            color: white;
        }

        .phase-1 { background-color: #ff6b6b; }
        .phase-12 { background-color: #96ceb4; }
        .phase-2 { background-color: #4ecdc4; }
        .phase-23 { background-color: #feca57; }
        .phase-3 { background-color: #8e44ad; }
        
        /* Enrollment Data Availability Styles */
        .eda { 
            background-color: #4ecdc4; 
            opacity: 0.8; 
        }
        .edna { 
            background-color: #4ecdc4; 
            opacity: 0.5; 
            border: 1px dashed #666; 
            box-sizing: border-box;
        }

        .stats-section {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #3282b8;
            display: block;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

        .track-breakdown {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .track-breakdown h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .track-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 0px;
        }

        .track-column {
            padding: 0 15px;
            border-right: 2px solid #000;
        }

        .track-column:last-child {
            border-right: none;
        }

        .track-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .track-item:last-child {
            border-bottom: none;
        }

        .track-name {
            font-weight: 500;
        }

        .track-count {
            color: #3282b8;
            font-weight: bold;
        }

        /* Mobile App Style Toggle Switch */
        .search-toggle-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(248, 249, 250, 0.8);
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .toggle-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            min-width: 120px;
            transition: all 0.3s ease;
        }

        .toggle-option .toggle-icon {
            font-size: 24px;
            transition: all 0.3s ease;
            opacity: 0.6;
        }

        .toggle-option .toggle-text {
            font-size: 13px;
            font-weight: 600;
            color: #6b7280;
            text-align: center;
            transition: all 0.3s ease;
        }

        .mobile-toggle-switch {
            position: relative;
            display: inline-block;
        }

        .mobile-toggle-input {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
        }

        .mobile-toggle-label {
            position: relative;
            display: block;
            width: 60px;
            height: 34px;
            background: #e5e7eb;
            border-radius: 17px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .mobile-toggle-label:hover {
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.15), 0 0 0 8px rgba(59, 130, 246, 0.05);
        }

        .mobile-toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 30px;
            height: 30px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .mobile-toggle-input:checked + .mobile-toggle-label {
            background: #10b981;
        }

        .mobile-toggle-input:checked + .mobile-toggle-label .mobile-toggle-slider {
            transform: translateX(26px);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3), 0 1px 4px rgba(0, 0, 0, 0.15);
        }

        .mobile-toggle-input:focus + .mobile-toggle-label {
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        /* Active state styling */
        .search-toggle-container:has(.mobile-toggle-input:checked) .toggle-option:first-child .toggle-icon {
            opacity: 0.4;
        }

        .search-toggle-container:has(.mobile-toggle-input:checked) .toggle-option:first-child .toggle-text {
            color: #9ca3af;
        }

        .search-toggle-container:has(.mobile-toggle-input:checked) .toggle-option:last-child .toggle-icon {
            opacity: 1;
            transform: scale(1.1);
        }

        .search-toggle-container:has(.mobile-toggle-input:checked) .toggle-option:last-child .toggle-text {
            color: #3b82f6;
            font-weight: 700;
        }

        .search-toggle-container:has(.mobile-toggle-input:not(:checked)) .toggle-option:first-child .toggle-icon {
            opacity: 1;
            transform: scale(1.1);
        }

        .search-toggle-container:has(.mobile-toggle-input:not(:checked)) .toggle-option:first-child .toggle-text {
            color: #374151;
            font-weight: 700;
        }

        /* Disabled state styling */
        .search-toggle-container.disabled {
            opacity: 0.5;
            pointer-events: none;
            filter: grayscale(0.5);
        }

        .search-toggle-container.disabled .toggle-option .toggle-icon,
        .search-toggle-container.disabled .toggle-option .toggle-text {
            opacity: 0.5;
            color: #9ca3af !important;
        }

        .search-toggle-container.disabled .mobile-toggle-label {
            background: #e5e7eb !important;
            cursor: not-allowed;
        }

        .search-toggle-container.disabled .mobile-toggle-slider {
            background: #d1d5db !important;
        }

        /* Natural Language Search Styles */
        .nl-search-section {
            background: linear-gradient(135deg, #0f4c75 0%, #3282b8 100%);
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            color: white;
            box-shadow: 0 8px 32px rgba(15, 76, 117, 0.3);
            display: none;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* TPS ID Search Styles */
        .tps-search-section {
            background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            color: white;
            box-shadow: 0 8px 32px rgba(142, 68, 173, 0.3);
            display: none;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .tps-search-section.show {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .tps-search-section h3 {
            font-size: 1.4rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .tps-description {
            margin-bottom: 20px;
            opacity: 0.9;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        #tps-query {
            flex: 1;
            padding: 16px 20px;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            min-height: 60px;
            background: rgba(255, 255, 255, 0.95);
            transition: all 0.3s ease;
            color: #333;
        }

        #tps-query:focus {
            outline: none;
            background: white;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3);
        }

        #tps-search-btn, #tps-clear-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #tps-search-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: none;
            font-weight: 600;
            letter-spacing: 0.02em;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        #tps-clear-btn {
            background: #ffffff;
            color: #374151;
            border: 1px solid #d1d5db;
            font-weight: 500;
            letter-spacing: 0.01em;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        #tps-search-btn:hover {
            background: linear-gradient(135deg, #c0392b 0%, #a93226 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(231, 76, 60, 0.3);
        }

        #tps-clear-btn:hover {
            background: #f8f9fa;
            border-color: #d1d5db;
            transform: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .nl-search-section.show {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .nl-search-section h3 {
            font-size: 1.4rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .nl-description {
            margin-bottom: 20px;
            opacity: 0.9;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        .search-input-container {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            align-items: center;
        }

        #nl-query {
            flex: 1;
            padding: 16px 20px;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            min-height: 60px;
            background: rgba(255, 255, 255, 0.95);
            transition: all 0.3s ease;
        }

        #nl-query:focus {
            outline: none;
            background: white;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3);
        }

        #nl-search-btn, #nl-clear-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #nl-search-btn {
            background: linear-gradient(135deg, #ffd60a 0%, #ffbe0b 100%);
            color: #1a1a1a;
            border: none;
            font-weight: 600;
            letter-spacing: 0.02em;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        #nl-clear-btn {
            background: #ffffff;
            color: #374151;
            border: 1px solid #d1d5db;
            font-weight: 500;
            letter-spacing: 0.01em;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        #nl-search-btn:hover {
            background: linear-gradient(135deg, #ffbe0b 0%, #ff9f1c 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 159, 28, 0.3);
        }

        #nl-clear-btn:hover {
            background: #f8f9fa;
            border-color: #d1d5db;
            transform: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        #nl-search-btn:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(255, 159, 28, 0.2);
        }

        #nl-clear-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        #nl-search-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s ease, height 0.3s ease;
        }

        #nl-clear-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s ease, height 0.3s ease;
        }

        #nl-search-btn:hover::before {
            width: 100%;
            height: 100%;
        }

        #nl-clear-btn:hover::before {
            width: 100%;
            height: 100%;
        }

        .suggested-queries {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .suggestion-label {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-right: 10px;
            font-weight: 500;
        }

        .suggestion {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .suggestion:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .search-status {
            margin-top: 15px;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .search-status.success {
            background: rgba(76, 175, 80, 0.2);
            color: #e8f5e8;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .search-status.info {
            background: rgba(33, 150, 243, 0.2);
            color: #e3f2fd;
            border: 1px solid rgba(33, 150, 243, 0.3);
        }

        .search-status.warning {
            background: rgba(255, 152, 0, 0.2);
            color: #fff3e0;
            border: 1px solid rgba(255, 152, 0, 0.3);
        }

        .search-status.error {
            background: rgba(244, 67, 54, 0.2);
            color: #ffebee;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Enhanced data point styling for search results */
        .data-point.search-highlighted {
            stroke: #3282b8;
            stroke-width: 4px;
            opacity: 1 !important;
            animation: searchPulse 2s infinite;
            filter: drop-shadow(0 0 8px rgba(50, 130, 184, 0.6));
        }

        .data-point.search-dimmed {
            opacity: 0.2;
            transition: opacity 0.5s ease;
        }

        /* TPS ID search highlighting */
        .data-point.tps-highlighted {
            stroke: #e74c3c;
            stroke-width: 5px;
            opacity: 1 !important;
            animation: tpsPulse 2s infinite;
            filter: drop-shadow(0 0 10px rgba(231, 76, 60, 0.8));
        }

        .data-point.tps-dimmed {
            opacity: 0.15;
            transition: opacity 0.5s ease;
        }

        @keyframes tpsPulse {
            0% { 
                stroke-width: 5px; 
                filter: drop-shadow(0 0 10px rgba(231, 76, 60, 0.8));
            }
            50% { 
                stroke-width: 7px; 
                filter: drop-shadow(0 0 15px rgba(231, 76, 60, 1));
            }
            100% { 
                stroke-width: 5px; 
                filter: drop-shadow(0 0 10px rgba(231, 76, 60, 0.8));
            }
        }

        @keyframes searchPulse {
            0% { 
                stroke-width: 4px; 
                filter: drop-shadow(0 0 8px rgba(50, 130, 184, 0.6));
            }
            50% { 
                stroke-width: 6px; 
                filter: drop-shadow(0 0 12px rgba(50, 130, 184, 0.8));
            }
            100% { 
                stroke-width: 4px; 
                filter: drop-shadow(0 0 8px rgba(50, 130, 184, 0.6));
            }
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .search-toggle-container {
                flex-direction: column;
                gap: 15px;
                padding: 15px;
            }
            
            .toggle-option {
                min-width: 100px;
            }
            
            .toggle-option .toggle-text {
                font-size: 12px;
            }
            
            .mobile-toggle-switch {
                order: -1;
            }
            
            .search-input-container {
                flex-direction: column;
            }
            
            #nl-query {
                margin-bottom: 10px;
            }
            
            .suggested-queries {
                justify-content: center;
            }
            
            .suggestion-label {
                width: 100%;
                text-align: center;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <a href="https://inventcures.github.io" class="homepage-link">Homepage</a>
            <h1>ASCO 2025 Clinical Trial Pipeline</h1>
            <p class="subtitle">Trials in Progress from the <a href="https://www.asco.org/meetings-events/annual-meeting" target="_blank">ASCO 2025 Annual Meeting</a></p>
            
            <div class="description">
                <p>This interactive dashboard visualizes 385 clinical trials in progress (TPS abstracts) reported at ASCO 2025. These represent the future of cancer treatment, featuring ongoing studies across multiple cancer types and novel therapeutic approaches. Each data point represents a trial currently enrolling or in development, providing insights into the clinical research pipeline across 12 different cancer tracks spanning from early-phase exploratory studies to large confirmatory trials.</p>
            </div>
            
            <p class="note">Note: This data is extracted from ASCO 2025 abstracts by <span class="author-name">Ashish Makani</span> (<a href="https://inventcures.github.io" target="_blank">homepage</a>, <a href="https://x.com/inventcures" target="_blank">X</a>) using LLMs. 
                Please report any data quality issues to spiff007@{free email service from Google}. </p>
                <p> <b>All data is the copyright of ASCO, ¬©ASCO. It is visualized here to be useful to the cancer research community.</b></p>
        </header>

        <div class="stats-section">
            <div class="stats-grid">
                <div class="stat-card">
                    <span class="stat-number">385</span>
                    <div class="stat-label">Total Clinical Trials</div>
                </div>
                <div class="stat-card">
                    <span class="stat-number">12</span>
                    <div class="stat-label">Cancer Tracks</div>
                </div>
                <div class="stat-card">
                    <span class="stat-number">165</span>
                    <div class="stat-label">Early Phase Trials (1 & 1/2)</div>
                </div>
                <div class="stat-card">
                    <span class="stat-number">86</span>
                    <div class="stat-label">Largest Track (Developmental Therapeutics)</div>
                </div>
            </div>
            
            <div class="track-breakdown">
                <h3>Distribution by Cancer Track</h3>
                <div class="track-list">
                    <div class="track-column">
                        <div class="track-item">
                            <span class="track-name">Developmental Therapeutics</span>
                            <span class="track-count">86 trials</span>
                        </div>
                        <div class="track-item">
                            <span class="track-name">Lung Cancer</span>
                            <span class="track-count">51 trials</span>
                        </div>
                        <div class="track-item">
                            <span class="track-name">Breast Cancer</span>
                            <span class="track-count">49 trials</span>
                        </div>
                    </div>
                    <div class="track-column">
                        <div class="track-item">
                            <span class="track-name">Genitourinary Cancers</span>
                            <span class="track-count">41 trials</span>
                        </div>
                        <div class="track-item">
                            <span class="track-name">Gastrointestinal Cancers</span>
                            <span class="track-count">40 trials</span>
                        </div>
                        <div class="track-item">
                            <span class="track-name">Melanoma/Skin Cancers</span>
                            <span class="track-count">39 trials</span>
                        </div>
                    </div>
                    <div class="track-column">
                        <div class="track-item">
                            <span class="track-name">Hematologic Malignancies</span>
                            <span class="track-count">36 trials</span>
                        </div>
                        <div class="track-item">
                            <span class="track-name">Gynecologic Cancers</span>
                            <span class="track-count">15 trials</span>
                        </div>
                        <div class="track-item">
                            <span class="track-name">CNS/Brain Tumors</span>
                            <span class="track-count">12 trials</span>
                        </div>
                    </div>
                    <div class="track-column">
                        <div class="track-item">
                            <span class="track-name">Sarcoma</span>
                            <span class="track-count">8 trials</span>
                        </div>
                        <div class="track-item">
                            <span class="track-name">Head and Neck Cancer</span>
                            <span class="track-count">5 trials</span>
                        </div>
                        <div class="track-item">
                            <span class="track-name">Quality Care/Health Services<br>Research</span>
                            <span class="track-count">3 trials</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <p style="margin-top: 20px; color: #666; line-height: 1.6;">
                This comprehensive dataset represents the cutting edge of cancer research, spanning 385 ongoing clinical trials across 12 distinct cancer tracks. The studies showcase breakthrough approaches including CAR-T cell therapies, antibody-drug conjugates (ADCs), next-generation checkpoint inhibitors, and innovative precision medicine strategies. With enrollment targets ranging from small Phase 1 dose-escalation studies of 12 patients to large confirmatory trials of 1149 participants (average: 116 patients per study), these investigations collectively represent billions of dollars in research investment and the therapeutic pipeline for millions of cancer patients worldwide. The dominance of developmental therapeutics (86 studies), lung cancer (51 studies), and breast cancer (49 studies) reflects both urgent unmet medical needs and significant recent advances in our molecular understanding of these diseases. The 165 early-phase trials (43% of all studies) demonstrate the experimental nature of this pipeline, featuring 167 distinct investigational agents from 38 companies worldwide.
            </p>
        </div>

        <!-- Search Mode Toggle -->
        <div class="search-toggle-container">
            <div class="toggle-option">
                <span class="toggle-icon">üìä</span>
                <span class="toggle-text">Static Trial Data with filters(to slice and dice the data) </span>
            </div>
            
            <div class="mobile-toggle-switch">
                <input type="checkbox" id="search-toggle-input" class="mobile-toggle-input">
                <label for="search-toggle-input" class="mobile-toggle-label">
                    <span class="mobile-toggle-slider"></span>
                </label>
            </div>
            
            <div class="toggle-option">
                <span class="toggle-icon">üîç</span>
                <span class="toggle-text">Search all trials using natural-language search</span>
            </div>
        </div>

        <!-- TPS ID Search Toggle -->
        <div class="search-toggle-container">
            <div class="toggle-option">
                <span class="toggle-icon">üìä</span>
                <span class="toggle-text">Show all trials (normal view)</span>
            </div>
            
            <div class="mobile-toggle-switch">
                <input type="checkbox" id="tps-search-toggle-input" class="mobile-toggle-input">
                <label for="tps-search-toggle-input" class="mobile-toggle-label">
                    <span class="mobile-toggle-slider"></span>
                </label>
            </div>
            
            <div class="toggle-option">
                <span class="toggle-icon">üéØ</span>
                <span class="toggle-text">Search by TPS ID to view a single trial's data(e.g., enter 2088 for TPS2088)</span>
            </div>
        </div>

        <!-- Natural Language Search Interface -->
        <div class="nl-search-section">
            <h3>üîç Natural Language Search</h3>
            <p class="nl-description">Hybrid search: keywords + TF-IDF semantic similarity + concept groups - try complex queries like medical abbreviations, drug names, or specific cancer types</p>
            
            <div class="search-input-container">
                <input type="text" id="nl-query" 
                       placeholder="e.g., 'PCa trials', 'HCC immunotherapy', 'Phase 3 breast cancer ADC studies', 'pembrolizumab NSCLC'">
                <button id="nl-search-btn">Search</button>
                <button id="nl-clear-btn">Clear</button>
            </div>
            
            <div class="suggested-queries">
                <span class="suggestion-label">Try these examples:</span>
                <span class="suggestion" data-query="PCa trials">PCa trials</span>
                <span class="suggestion" data-query="HCC immunotherapy">HCC immunotherapy</span>
                <span class="suggestion" data-query="breast cancer ADC">Breast cancer ADC</span>
                <span class="suggestion" data-query="Phase 3 lung cancer">Phase 3 lung cancer</span>
                <span class="suggestion" data-query="CAR-T therapy">CAR-T therapy</span>
                <span class="suggestion" data-query="pembrolizumab NSCLC">Pembrolizumab NSCLC</span>
                <span class="suggestion" data-query="early phase liver cancer">Early phase liver cancer</span>
                <span class="suggestion" data-query="TNBC checkpoint inhibitor">TNBC checkpoint inhibitor</span>
            </div>
            
            <div id="search-status" class="search-status"></div>
        </div>

        <!-- TPS ID Search Interface -->
        <div class="tps-search-section">
            <h3>üéØ TPS ID Search</h3>
            <p class="tps-description">Search for a specific trial by TPS ID. Enter just the number (e.g., 2088 for TPS2088). Found trial will be displayed alone on the plot.</p>
            
            <div class="search-input-container">
                <input type="text" id="tps-query" 
                       placeholder="e.g., 2088, 1120, 3649">
                <button id="tps-search-btn">Search</button>
                <button id="tps-clear-btn">Clear</button>
            </div>
            
            <div id="tps-search-status" class="search-status"></div>
        </div>

        <div class="controls">
            <div class="filter-group">
                <label for="population-filter">Filter by patient population/subgroup</label>
                <select id="population-filter" class="filter-select">
                    <option value="">All populations</option>
                </select>
            </div>

            <div class="filter-group">
                <label for="phase-filter">Type of trial (Phase)</label>
                <select id="phase-filter" class="filter-select">
                    <option value="">All phases</option>
                    <option value="Phase 1">Phase 1</option>
                    <option value="Phase 2">Phase 2</option>
                    <option value="Phase 3">Phase 3</option>
                    <option value="Phase 1/2">Phase 1/2</option>
                    <option value="Phase 2/3">Phase 2/3</option>
                </select>
            </div>

            <div class="filter-group">
                <label for="company-filter">Filter by company</label>
                <select id="company-filter" class="filter-select">
                    <option value="">All companies</option>
                </select>
            </div>

            <div class="filter-group">
                <label for="trial-filter">Filter by trial name</label>
                <select id="trial-filter" class="filter-select">
                    <option value="">All trials</option>
                </select>
            </div>

            <div class="filter-group">
                <label for="drug-filter">Filter by drug</label>
                <select id="drug-filter" class="filter-select">
                    <option value="">All drugs</option>
                </select>
            </div>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div class="cancer-type-list">
                    <div class="cancer-type-item active" data-track="all">All tracks</div>
                </div>
            </div>

            <div class="chart-container">
                <!-- Floating Search Bar -->
                <div id="floating-search-bar" class="floating-search-bar">
                    <button class="floating-close-btn" id="floating-close-btn">√ó</button>
                    <div class="search-input-container">
                        <input type="text" id="floating-nl-query" 
                               placeholder="e.g., 'PCa trials', 'HCC immunotherapy', 'Phase 3 breast cancer ADC studies'">
                        <button id="floating-nl-search-btn">Search</button>
                        <button id="floating-nl-clear-btn">Clear</button>
                    </div>
                    <div id="floating-search-status" class="search-status"></div>
                </div>
                
                <div id="scatter-plot"></div>
                <div class="legend">
                    <div class="legend-item">
                        <span class="legend-dot phase-1"></span>
                        <span>Phase 1</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-dot phase-12"></span>
                        <span>Phase 1/2</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-dot phase-2"></span>
                        <span>Phase 2</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-dot phase-23"></span>
                        <span>Phase 2/3</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-dot phase-3"></span>
                        <span>Phase 3</span>
                    </div>
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <span class="legend-dot eda"></span>
                        <span>Enrollment Data Available</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-dot edna"></span>
                        <span>Enrollment Data Not Available</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="background-section">
            <h2>Background</h2>
            <p>The trials shown above are from ASCO 2025 "Trials in Progress" (TPS) abstracts. These represent ongoing clinical studies that are actively enrolling patients or in development phases. Unlike completed trial results, TPS abstracts provide insights into the future pipeline of cancer therapeutics and research directions. This dashboard helps researchers, clinicians, and patients understand what treatments are being developed and tested across different cancer types.</p>
        </div>
    </div>

    <!-- Tooltip -->
    <div id="tooltip" class="tooltip" style="display: none;">
        <div class="tooltip-content">
            <div class="tooltip-title"></div>
            <div class="tooltip-details"></div>
        </div>
    </div>

    <script src="asco2025_comprehensive_data.js?v=20250603_1915"></script>
    <script src="lightweight_hybrid_search.js"></script>
    <script>
        // API Key Configuration - uses indirection for security
        window.API_CONFIG = {
            // Set your key reference here (e.g., 'my_secret_key')
            keyRef: 'ASCO_LLM_KEY',
            
            // The actual key is stored separately in localStorage/sessionStorage
            getApiKey: function() {
                return localStorage.getItem(this.keyRef) || 
                       sessionStorage.getItem(this.keyRef) ||
                       window[this.keyRef];
            }
        };
        
        // Auto-configure API key for convenience
        if (!localStorage.getItem('ASCO_LLM_KEY')) {
            localStorage.setItem('ASCO_LLM_KEY', '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');
            console.log('üîë Auto-configured Groq API key');
        }
    </script>
    <script>

// Dashboard JavaScript
class ASCOTrialDashboard {
    constructor() {
        console.log('Dashboard constructor called');
        console.log('ascoTrialData available:', typeof ascoTrialData, ascoTrialData ? ascoTrialData.length : 'undefined');
        this.data = ascoTrialData;
        this.filteredData = [...this.data];
        this.selectedTrack = '';
        this.searchResults = [];
        this.activeSearch = false;
        this.currentSearchQuery = '';
        this.searchCorpus = null;
        this.llmSummary = null;
        this.tpsSearchActive = false;
        this.currentTpsSearchId = '';
        this.margin = { top: 20, right: 60, bottom: 60, left: 60 };
        this.width = 800 - this.margin.left - this.margin.right;
        this.height = 500 - this.margin.bottom - this.margin.top;
        
        console.log('D3 available:', typeof d3);
        this.init();
        
        // Show loading message for search corpus
        this.showSearchStatus('Loading search index...', 'info');
    }

    init() {
        this.setupFilters();
        this.setupSidebar();
        this.createChart();
        this.setupTooltip();
        this.loadSearchCorpus();
        this.setupNaturalLanguageSearch();
        this.setupTpsIdSearch();
    }

    setupFilters() {
        // Extract unique values for each filter type
        const populations = [...new Set(this.data.map(d => d.targetPopulation).filter(p => p))].sort();
        const companies = [...new Set(this.data.map(d => d.company).filter(c => c))].sort();
        const trialNames = [...new Set(this.data.map(d => d.trialName).filter(t => t))].sort();
        const drugs = [...new Set(this.data.map(d => d.drug).filter(d => d))].sort();

        // Populate population filter
        const populationFilter = document.getElementById('population-filter');
        populations.forEach(population => {
            const option = document.createElement('option');
            option.value = population;
            option.textContent = population;
            populationFilter.appendChild(option);
        });

        // Populate company filter
        const companyFilter = document.getElementById('company-filter');
        companies.forEach(company => {
            const option = document.createElement('option');
            option.value = company;
            option.textContent = company;
            companyFilter.appendChild(option);
        });

        // Populate trial name filter
        const trialFilter = document.getElementById('trial-filter');
        trialNames.forEach(trial => {
            const option = document.createElement('option');
            option.value = trial;
            option.textContent = trial;
            trialFilter.appendChild(option);
        });

        // Populate drug filter
        const drugFilter = document.getElementById('drug-filter');
        drugs.forEach(drug => {
            const option = document.createElement('option');
            option.value = drug;
            option.textContent = drug;
            drugFilter.appendChild(option);
        });

        // Add event listeners for all filters
        populationFilter.addEventListener('change', () => this.applyFilters());
        document.getElementById('phase-filter').addEventListener('change', () => this.applyFilters());
        companyFilter.addEventListener('change', () => this.applyFilters());
        trialFilter.addEventListener('change', () => this.applyFilters());
        drugFilter.addEventListener('change', () => this.applyFilters());
    }

    setupSidebar() {
        const sidebar = document.querySelector('.cancer-type-list');
        const tracks = [...new Set(this.data.map(d => d.track))].sort();
        
        tracks.forEach(track => {
            const item = document.createElement('div');
            item.className = 'cancer-type-item';
            item.textContent = track;
            item.setAttribute('data-track', track);
            item.addEventListener('click', () => this.selectTrack(track));
            sidebar.appendChild(item);
        });

        const allItem = sidebar.querySelector('[data-track="all"]');
        allItem.addEventListener('click', () => this.selectTrack('all'));
    }

    selectTrack(track) {
        document.querySelectorAll('.cancer-type-item').forEach(item => {
            item.classList.remove('active');
        });
        
        const selectedItem = document.querySelector(`[data-track="${track}"]`);
        if (selectedItem) {
            selectedItem.classList.add('active');
        }

        this.selectedTrack = track === 'all' ? '' : track;
        this.applyFilters();
    }

    applyFilters() {
        const populationFilter = document.getElementById('population-filter').value;
        const phaseFilter = document.getElementById('phase-filter').value;
        const companyFilter = document.getElementById('company-filter').value;
        const trialFilter = document.getElementById('trial-filter').value;
        const drugFilter = document.getElementById('drug-filter').value;

        this.filteredData = this.data.filter(d => {
            const matchesTrack = !this.selectedTrack || d.track === this.selectedTrack;
            const matchesPopulation = !populationFilter || d.targetPopulation === populationFilter;
            const matchesPhase = !phaseFilter || d.trialPhase === phaseFilter;
            const matchesCompany = !companyFilter || d.company === companyFilter;
            const matchesTrial = !trialFilter || d.trialName === trialFilter;
            const matchesDrug = !drugFilter || d.drug === drugFilter;
            
            return matchesTrack && matchesPopulation && matchesPhase && matchesCompany && matchesTrial && matchesDrug;
        });

        // Update search status and highlighting if search is active
        if (this.activeSearch && this.searchResults.length > 0) {
            this.updateSearchStatusWithFilters();
            this.updateSearchHighlightingWithFilters();
        }

        // If TPS search is active, override filtered data to show only the searched trial
        if (this.tpsSearchActive && this.currentTpsSearchId) {
            const trial = this.data.find(t => t.tpsId === this.currentTpsSearchId);
            if (trial) {
                this.filteredData = [trial];
            }
        }

        this.updateChart();
    }

    createChart() {
        d3.select("#scatter-plot").selectAll("*").remove();

        const svg = d3.select("#scatter-plot")
            .append("svg")
            .attr("width", this.width + this.margin.left + this.margin.right)
            .attr("height", this.height + this.margin.top + this.margin.bottom);

        this.g = svg.append("g")
            .attr("transform", `translate(${this.margin.left},${this.margin.top})`);

        this.xScale = d3.scaleLinear().range([0, this.width]);
        this.yScale = d3.scaleLinear().range([this.height, 0]);

        this.xAxis = d3.axisBottom(this.xScale).tickFormat(d3.format("d"));
        this.yAxis = d3.axisLeft(this.yScale);

        this.g.append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(0,${this.height})`);

        this.g.append("g")
            .attr("class", "y-axis");

        this.g.append("text")
            .attr("class", "axis-title")
            .attr("transform", `translate(${this.width/2}, ${this.height + 45})`)
            .style("text-anchor", "middle")
            .text("Estimated Enrollment");

        this.g.append("text")
            .attr("class", "axis-title")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - this.margin.left)
            .attr("x", 0 - (this.height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("Trial Index (by Phase)");

        this.updateChart();
    }

    updateChart() {
        console.log('UpdateChart called. FilteredData length:', this.filteredData.length);
        
        // Separate data into trials with and without enrollment data
        const trialsWithEnrollment = this.filteredData.filter(d => d.estimatedEnrollment > 0 && d.enrollmentSource === 'actual');
        const trialsWithoutEnrollment = this.filteredData.filter(d => !d.estimatedEnrollment || d.estimatedEnrollment <= 0 || d.enrollmentSource !== 'actual');
        
        console.log('Trials with enrollment:', trialsWithEnrollment.length);
        console.log('Trials without enrollment:', trialsWithoutEnrollment.length);
        
        // Create y-position based on phase
        const phaseOrder = ["Phase 1", "Phase 1/2", "Phase 2", "Phase 2/3", "Phase 3"];
        
        // Position trials with enrollment data
        const dataWithEnrollmentAndPosition = trialsWithEnrollment.map((d, i) => ({
            ...d,
            yPosition: phaseOrder.indexOf(d.trialPhase) * 100 + (i % 5) * 15 + 50,
            hasEnrollmentData: true
        }));
        
        // Position trials without enrollment data using trial index as fallback
        const dataWithoutEnrollmentAndPosition = trialsWithoutEnrollment.map((d, i) => ({
            ...d,
            yPosition: phaseOrder.indexOf(d.trialPhase) * 100 + (i % 5) * 15 + 50,
            fallbackXPosition: i + 1, // Use index as x-position
            hasEnrollmentData: false
        }));
        
        // Combine all data
        const allDataWithPosition = [...dataWithEnrollmentAndPosition, ...dataWithoutEnrollmentAndPosition];
        console.log('All data with position length:', allDataWithPosition.length);

        // Set up scales for both types of data
        const enrollmentExtent = trialsWithEnrollment.length > 0 ? 
            d3.extent(trialsWithEnrollment, d => d.estimatedEnrollment) : [0, 100];
        
        // Use enrollment data for x-scale if available, otherwise show all data across full width
        const maxEnrollment = enrollmentExtent[1] || 100;
        const maxFallbackIndex = trialsWithoutEnrollment.length || 10;
        
        this.xScale.domain([0, Math.max(maxEnrollment * 1.1, maxFallbackIndex * 50)]);
        this.yScale.domain([0, 500]);

        // Update axis label based on what we're showing
        const hasEnrollmentData = trialsWithEnrollment.length > 0;
        const hasNonEnrollmentData = trialsWithoutEnrollment.length > 0;
        
        let xAxisLabel = "Estimated Enrollment";
        if (hasEnrollmentData && hasNonEnrollmentData) {
            xAxisLabel = "Estimated Enrollment (actual data) / Trial Index (no enrollment data)";
        } else if (!hasEnrollmentData && hasNonEnrollmentData) {
            xAxisLabel = "Trial Index (no enrollment data available)";
        }
        
        this.g.select(".x-axis-label").text(xAxisLabel);

        this.g.select(".x-axis")
            .transition()
            .duration(750)
            .call(this.xAxis);

        this.g.select(".y-axis")
            .transition()
            .duration(750)
            .call(this.yAxis);

        const circles = this.g.selectAll(".data-point")
            .data(allDataWithPosition, d => d.tpsId);

        circles.exit()
            .transition()
            .duration(500)
            .attr("r", 0)
            .remove();

        const circlesEnter = circles.enter()
            .append("circle")
            .attr("class", "data-point")
            .attr("r", 0)
            .attr("cx", d => {
                if (d.hasEnrollmentData) {
                    return this.xScale(d.estimatedEnrollment);
                } else {
                    // Position trials without enrollment data across the available space
                    return this.xScale(d.fallbackXPosition * 50);
                }
            })
            .attr("cy", d => this.yScale(d.yPosition));

        // Merge circles and apply static attributes first
        const mergedCircles = circles.merge(circlesEnter);
        
        // Apply event handlers immediately (before transition)
        mergedCircles
            .on("mouseover", (event, d) => this.showTooltip(event, d))
            .on("mouseout", () => this.hideTooltip())
            .on("mousemove", (event) => this.moveTooltip(event))
            .on("click", (event, d) => this.openPDF(d));
            
        // Then apply animated attributes
        mergedCircles
            .transition()
            .duration(750)
            .attr("cx", d => {
                if (d.hasEnrollmentData) {
                    return this.xScale(d.estimatedEnrollment);
                } else {
                    return this.xScale(d.fallbackXPosition * 50);
                }
            })
            .attr("cy", d => this.yScale(d.yPosition))
            .attr("r", 8)
            .attr("fill", d => this.getPhaseColor(d.trialPhase))
            .attr("opacity", d => d.hasEnrollmentData ? 0.8 : 0.5)
            .attr("stroke", d => d.hasEnrollmentData ? "none" : "#666")
            .attr("stroke-width", d => d.hasEnrollmentData ? 0 : 1)
            .attr("stroke-dasharray", d => d.hasEnrollmentData ? "none" : "3,3");

        // Enrollment legend is now handled by static HTML

        // Reapply search highlighting if search is active
        if (this.activeSearch && this.searchResults.length > 0) {
            this.updateSearchHighlightingWithFilters();
        }
    }

    updateEnrollmentLegend(hasEnrollmentData, hasNonEnrollmentData, enrollmentCount, noEnrollmentCount) {
        // Check if svg exists (might be undefined if chart creation failed)
        if (!this.svg) {
            console.warn('‚ö†Ô∏è SVG not available, skipping enrollment legend');
            return;
        }
        
        // Remove existing enrollment legend
        this.svg.selectAll(".enrollment-legend").remove();
        
        if (!hasEnrollmentData && !hasNonEnrollmentData) return;
        
        const legendGroup = this.svg.append("g")
            .attr("class", "enrollment-legend")
            .attr("transform", "translate(800, 20)");
        
        console.log('üìä Creating enrollment legend with:', enrollmentCount, 'with data,', noEnrollmentCount, 'without data');
        
        let legendY = 0;
        
        // Legend title
        legendGroup.append("text")
            .attr("x", 0)
            .attr("y", legendY)
            .attr("font-size", "14px")
            .attr("font-weight", "bold")
            .attr("fill", "white")
            .text("Data Availability:");
        
        legendY += 25;
        
        if (hasEnrollmentData) {
            // Solid circle for trials with enrollment data
            legendGroup.append("circle")
                .attr("cx", 8)
                .attr("cy", legendY - 5)
                .attr("r", 6)
                .attr("fill", "#4ecdc4")
                .attr("opacity", 0.8);
            
            legendGroup.append("text")
                .attr("x", 20)
                .attr("y", legendY)
                .attr("font-size", "12px")
                .attr("fill", "white")
                .text(`With enrollment data (${enrollmentCount} trials)`);
            
            legendY += 20;
        }
        
        if (hasNonEnrollmentData) {
            // Dashed circle for trials without enrollment data
            legendGroup.append("circle")
                .attr("cx", 8)
                .attr("cy", legendY - 5)
                .attr("r", 6)
                .attr("fill", "#4ecdc4")
                .attr("opacity", 0.5)
                .attr("stroke", "#666")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "3,3");
            
            legendGroup.append("text")
                .attr("x", 20)
                .attr("y", legendY)
                .attr("font-size", "12px")
                .attr("fill", "white")
                .text(`No enrollment data (${noEnrollmentCount} trials)`);
        }
        
        // Add visual style legend below
        legendY += 40;
        
        // Visual style legend title
        legendGroup.append("text")
            .attr("x", 0)
            .attr("y", legendY)
            .attr("font-size", "14px")
            .attr("font-weight", "bold")
            .attr("fill", "white")
            .text("Visual Styles:");
        
        legendY += 25;
        
        // Solid circle legend
        legendGroup.append("circle")
            .attr("cx", 8)
            .attr("cy", legendY - 5)
            .attr("r", 6)
            .attr("fill", "#4ecdc4")
            .attr("opacity", 0.8);
        
        legendGroup.append("text")
            .attr("x", 20)
            .attr("y", legendY)
            .attr("font-size", "12px")
            .attr("fill", "white")
            .text("Solid circles = Actual enrollment data");
        
        legendY += 20;
        
        // Dashed circle legend
        legendGroup.append("circle")
            .attr("cx", 8)
            .attr("cy", legendY - 5)
            .attr("r", 6)
            .attr("fill", "#4ecdc4")
            .attr("opacity", 0.5)
            .attr("stroke", "#666")
            .attr("stroke-width", 1)
            .attr("stroke-dasharray", "3,3");
        
        legendGroup.append("text")
            .attr("x", 20)
            .attr("y", legendY)
            .attr("font-size", "12px")
            .attr("fill", "white")
            .text("Dashed circles = No enrollment data");
    }

    getPhaseColor(phase) {
        const colorMap = {
            "Phase 1": "#ff6b6b",
            "Phase 1/2": "#96ceb4",
            "Phase 2": "#4ecdc4",
            "Phase 2/3": "#feca57",
            "Phase 3": "#8e44ad"
        };
        return colorMap[phase] || "#999";
    }

    setupTooltip() {
        this.tooltip = d3.select("#tooltip");
        console.log('üõ†Ô∏è Tooltip setup:', this.tooltip.node() ? 'Found' : 'NOT FOUND');
        if (!this.tooltip.node()) {
            console.error('‚ùå Tooltip element #tooltip not found in DOM!');
            // Try to create tooltip element if it doesn't exist
            this.tooltip = d3.select("body").append("div")
                .attr("id", "tooltip")
                .attr("class", "tooltip")
                .style("display", "none")
                .style("position", "absolute")
                .style("background", "rgba(0, 0, 0, 0.9)")
                .style("color", "white")
                .style("padding", "10px")
                .style("border-radius", "5px")
                .style("pointer-events", "none")
                .style("z-index", "1000");
            console.log('üõ†Ô∏è Created new tooltip element');
        }
    }

    extractResponseMetrics(trial) {
        // Extract response rates and metrics from title and abstract
        const searchText = `${trial.title} ${trial.backgroundExcerpt}`.toLowerCase();
        const responseMetrics = [];
        
        // Pattern matching for various response metrics with metric name extraction
        const patterns = [
            { regex: /orr.*?(\d+(?:\.\d+)?%)/gi, metricName: 'ORR' },
            { regex: /objective response rate.*?(\d+(?:\.\d+)?%)/gi, metricName: 'Objective Response Rate' },
            { regex: /(\d+(?:\.\d+)?%).*?orr/gi, metricName: 'ORR' },
            { regex: /(\d+(?:\.\d+)?%).*?objective response/gi, metricName: 'Objective Response Rate' },
            { regex: /complete response rate.*?(\d+(?:\.\d+)?%)/gi, metricName: 'Complete Response Rate' },
            { regex: /crr.*?(\d+(?:\.\d+)?%)/gi, metricName: 'CRR' },
            { regex: /(\d+(?:\.\d+)?%).*?complete response/gi, metricName: 'Complete Response Rate' },
            { regex: /disease control rate.*?(\d+(?:\.\d+)?%)/gi, metricName: 'Disease Control Rate' },
            { regex: /dcr.*?(\d+(?:\.\d+)?%)/gi, metricName: 'DCR' },
            { regex: /(\d+(?:\.\d+)?%).*?disease control/gi, metricName: 'Disease Control Rate' },
            { regex: /response rate.*?(\d+(?:\.\d+)?%)/gi, metricName: 'Response Rate' },
            { regex: /(\d+(?:\.\d+)?%).*?response rate/gi, metricName: 'Response Rate' },
            { regex: /pathological complete response.*?(\d+(?:\.\d+)?%)/gi, metricName: 'Pathological Complete Response' },
            { regex: /pcr.*?(\d+(?:\.\d+)?%)/gi, metricName: 'PCR' },
            { regex: /(\d+(?:\.\d+)?%).*?response/gi, metricName: 'Response' }
        ];
        
        patterns.forEach(pattern => {
            const matches = [...searchText.matchAll(pattern.regex)];
            matches.forEach(match => {
                const percentMatch = match[0].match(/(\d+(?:\.\d+)?%)/);
                if (percentMatch) {
                    responseMetrics.push({
                        value: percentMatch[1],
                        metricName: pattern.metricName,
                        context: match[0].replace(/\s+/g, ' ').trim()
                    });
                }
            });
        });
        
        // Remove duplicates based on value and metric name
        const uniqueMetrics = responseMetrics.filter((metric, index, self) => 
            index === self.findIndex(m => m.value === metric.value && m.metricName === metric.metricName)
        );
        
        return uniqueMetrics.slice(0, 3); // Limit to 3 most relevant metrics
    }

    showTooltip(event, d) {
        // console.log('üéØ Tooltip triggered for:', d.tpsId, d);
        
        // Check if tooltip exists
        if (!this.tooltip || !this.tooltip.node()) {
            console.error('‚ùå Tooltip not available, reinitializing...');
            this.setupTooltip();
            if (!this.tooltip || !this.tooltip.node()) {
                console.error('‚ùå Tooltip reinitialization failed');
                return;
            }
        }
        
        const abstractText = `Click to view the full ${d.tpsId} abstract with trial details.`;
        
        // Use pre-extracted response metrics from data structure
        const responseMetrics = d.responseMetrics || [];
        
        // Debug: Log LLM summary status
        console.log('üîç Tooltip Debug - LLM Summary:', this.llmSummary ? 'Available' : 'Not available');
        console.log('üîç Tooltip Debug - API Key:', this.getGroqApiKey() ? 'Configured' : 'Missing');
        console.log('üîç Tooltip Debug - Active Search:', this.activeSearch);
        console.log('üîç Tooltip Debug - Response Metrics Found:', responseMetrics.length);
        
        // Check if we have an API key but no LLM summary and this is from a search
        const apiKey = this.getGroqApiKey();
        const hasApiKey = !!apiKey;
        const showLLMStatus = hasApiKey && this.activeSearch;
        
        // Build response metrics section in the requested format
        let responseSection = '';
        if (responseMetrics.length > 0) {
            responseSection = responseMetrics.map(metric => 
                `<div><strong>Response Data(${metric.metricName}):</strong> <span style="color: #4fc3f7; font-weight: bold;">${metric.value}</span></div>`
            ).join('');
        }
        
        this.tooltip.html(`
            <div class="tooltip-title">${d.title}</div>
            <div class="tooltip-details">
                <div><strong>TPS ID:</strong> ${d.tpsId}</div>
                <div><strong>Track:</strong> ${d.trackFull || d.track}</div>
                <div><strong>Phase:</strong> ${d.trialPhase}</div>
                <div><strong>Cancer Type:</strong> ${d.cancerType}</div>
                <div><strong>Drug:</strong> ${d.drug}</div>
                ${responseSection}
                <div><strong>Target Population:</strong> ${d.targetPopulation}</div>
                <div><strong>Primary Endpoint:</strong> ${d.primaryEndpoint}</div>
                ${d.enrollmentSource === 'actual' ? `<div><strong>Estimated Enrollment:</strong> ${d.estimatedEnrollment} patients</div>` : ''}
                ${d.trialRegistry ? `<div><strong>Registry:</strong> ${d.trialRegistry}</div>` : ''}
                ${d.originalPdfUrl ? `<div><strong>Abstract URL:</strong> <a href="${d.originalPdfUrl}" target="_blank" style="color: #64ffda; text-decoration: underline;">${d.originalPdfUrl}</a></div>` : ''}
                <div class="abstract-preview"><strong>Background:</strong> ${d.backgroundExcerpt}</div>
                ${this.llmSummary ? `<div class="llm-summary"><strong>üß† AI Insight:</strong> ${this.llmSummary}<br><em style="font-size: 10px; color: #ccc;">Generated by LLM - Ancillary information</em></div>` : 
                  showLLMStatus && !this.llmSummary ? `<div class="llm-summary"><strong>üß† AI Insight:</strong> <span style="color: #ffa726;">Generating insights...</span><br><em style="font-size: 10px; color: #ccc;">This may take a few seconds</em></div>` :
                  showLLMStatus === false && !hasApiKey ? `<div class="llm-summary"><strong>üß† AI Insight:</strong> <span style="color: #ff9800;">Configure API key for insights</span><br><em style="font-size: 10px; color: #ccc;">Run: localStorage.setItem('ASCO_LLM_KEY', 'your-key')</em></div>` : ''}
                <div class="tooltip-action">Click to view full PDF abstract</div>
            </div>
        `);

        this.tooltip.style("display", "block");
        this.moveTooltip(event);
    }

    moveTooltip(event) {
        // console.log('üìç Moving tooltip', event.pageX, event.pageY);
        
        // Check if tooltip exists
        if (!this.tooltip || !this.tooltip.node()) {
            console.error('‚ùå Tooltip not available for move');
            return;
        }
        
        const tooltipWidth = this.tooltip.node().offsetWidth;
        const tooltipHeight = this.tooltip.node().offsetHeight;
        
        let left = event.pageX + 10;
        let top = event.pageY - 10;
        
        if (left + tooltipWidth > window.innerWidth) {
            left = event.pageX - tooltipWidth - 10;
        }
        
        if (top + tooltipHeight > window.innerHeight) {
            top = event.pageY - tooltipHeight - 10;
        }
        
        this.tooltip
            .style("left", left + "px")
            .style("top", top + "px");
    }

    hideTooltip() {
        // console.log('üôà Hiding tooltip');
        
        // Check if tooltip exists
        if (!this.tooltip || !this.tooltip.node()) {
            console.error('‚ùå Tooltip not available for hide');
            return;
        }
        
        this.tooltip.style("display", "none");
    }

    openPDF(trial) {
        // Use original CloudFront URL if available, otherwise fall back to local PDF
        if (trial.originalPdfUrl && trial.originalPdfUrl.trim() !== '') {
            window.open(trial.originalPdfUrl, '_blank');
        } else {
            // Fallback to local PDF
            const pdfFileName = `${trial.tpsId}.pdf`;
            const baseUrl = window.location.href.split('/').slice(0, -1).join('/');
            const pdfUrl = `${baseUrl}/tps_abstracts/${pdfFileName}`;
            window.open(pdfUrl, '_blank');
        }
    }

    // Natural Language Search Methods
    async loadSearchCorpus() {
        try {
            // Use embedded lightweight hybrid search corpus (avoids CORS issues)
            if (typeof lightweightHybridSearchData !== 'undefined') {
                this.searchCorpus = lightweightHybridSearchData;
                console.log('‚úÖ Lightweight hybrid search corpus loaded:', this.searchCorpus.total_trials, 'trials,', this.searchCorpus.vocab_size, 'vocab terms');
                this.showSearchStatus('üîç Hybrid search ready! Try "PCa trials" or "HCC immunotherapy"', 'success');
                return;
            }

            // Fallback to basic embedded search corpus
            if (typeof searchCorpusData !== 'undefined') {
                this.searchCorpus = searchCorpusData;
                console.log('‚úÖ Basic search corpus loaded:', this.searchCorpus.total_trials, 'trials');
                this.showSearchStatus('üîç Natural language search ready! Try "PCa trials" or "HCC immunotherapy"', 'success');
                return;
            }

            // Fallback: try to fetch from server (works with http://)
            console.log('üì• Loading search corpus from server...');
            const response = await fetch('search_corpus.json');
            this.searchCorpus = await response.json();
            console.log('‚úÖ Search corpus loaded from server:', this.searchCorpus.total_trials, 'trials');
            this.showSearchStatus('üîç Natural language search ready! Try "PCa trials" or "HCC immunotherapy"', 'success');
        } catch (error) {
            console.error('‚ùå Failed to load search corpus:', error);
            this.showSearchStatus('‚ùå Search index failed to load. Please refresh or use a web server.', 'warning');
        }
    }

    setupNaturalLanguageSearch() {
        const searchBtn = document.getElementById('nl-search-btn');
        const clearBtn = document.getElementById('nl-clear-btn');
        const queryInput = document.getElementById('nl-query');
        const statusDiv = document.getElementById('search-status');
        const toggleInput = document.getElementById('search-toggle-input');
        const searchSection = document.querySelector('.nl-search-section');

        // Toggle functionality
        const handleToggle = () => {
            const isSearchVisible = toggleInput.checked;
            const tpsToggle = document.getElementById('tps-search-toggle-input');
            
            if (isSearchVisible) {
                // Show search section
                searchSection.style.display = 'block';
                setTimeout(() => {
                    searchSection.classList.add('show');
                }, 10);
                
                // Disable TPS search toggle when natural language search is active
                tpsToggle.disabled = true;
                tpsToggle.checked = false;
                this.clearTpsSearch();
                
                // Add visual feedback for disabled state
                const tpsToggleContainer = tpsToggle.closest('.search-toggle-container');
                tpsToggleContainer.classList.add('disabled');
            } else {
                // Hide search section
                searchSection.classList.remove('show');
                setTimeout(() => {
                    searchSection.style.display = 'none';
                }, 400);
                
                // Re-enable TPS search toggle when natural language search is turned off
                tpsToggle.disabled = false;
                
                // Remove visual feedback for disabled state
                const tpsToggleContainer = tpsToggle.closest('.search-toggle-container');
                tpsToggleContainer.classList.remove('disabled');
                
                // Don't clear search when just hiding UI - preserve results and LLM summary
                // this.clearSearch(); // REMOVED: Allows LLM summary to persist when UI is hidden
            }
        };
        
        // Add event listener
        toggleInput.addEventListener('change', (e) => {
            // Prevent toggle if disabled
            if (toggleInput.disabled) {
                e.preventDefault();
                return false;
            }
            handleToggle();
        });

        // Search button click
        searchBtn.addEventListener('click', () => {
            const query = queryInput.value.trim();
            if (query) {
                this.performNaturalLanguageSearch(query);
            }
        });

        // Clear button click
        clearBtn.addEventListener('click', () => {
            this.clearSearch();
        });

        // Enter key in search input
        queryInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const query = queryInput.value.trim();
                if (query) {
                    this.performNaturalLanguageSearch(query);
                }
            }
        });

        // Suggestion clicks
        document.querySelectorAll('.suggestion').forEach(suggestion => {
            suggestion.addEventListener('click', () => {
                const query = suggestion.getAttribute('data-query');
                queryInput.value = query;
                this.performNaturalLanguageSearch(query);
            });
        });

        // Floating search bar controls
        const floatingSearchBtn = document.getElementById('floating-nl-search-btn');
        const floatingClearBtn = document.getElementById('floating-nl-clear-btn');
        const floatingQueryInput = document.getElementById('floating-nl-query');
        const floatingCloseBtn = document.getElementById('floating-close-btn');

        // Floating search button click
        floatingSearchBtn.addEventListener('click', () => {
            const query = floatingQueryInput.value.trim();
            if (query) {
                this.performNaturalLanguageSearch(query, true); // true for floating mode
            }
        });

        // Floating clear button click
        floatingClearBtn.addEventListener('click', () => {
            this.clearSearch();
        });

        // Floating enter key
        floatingQueryInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const query = floatingQueryInput.value.trim();
                if (query) {
                    this.performNaturalLanguageSearch(query, true); // true for floating mode
                }
            }
        });

        // Floating close button
        floatingCloseBtn.addEventListener('click', () => {
            this.hideFloatingSearchBar();
        });
    }

    performNaturalLanguageSearch(query, floatingMode = false) {
        if (!this.searchCorpus) {
            this.showSearchStatus('Search index loading... Please wait a moment and try again.', 'info');
            // Try to reload the search corpus
            this.loadSearchCorpus();
            return;
        }

        console.log('üîç Searching for:', query);
        
        // Expand abbreviations
        const expandedQuery = this.expandMedicalAbbreviations(query.toLowerCase());
        console.log('üìù Expanded query:', expandedQuery);

        // Perform search
        const results = this.searchTrials(expandedQuery);
        this.searchResults = results;
        this.activeSearch = true;
        this.currentSearchQuery = query;

        // Update UI
        if (results.length > 0) {
            const hasSemanticSearch = this.searchCorpus.vocabulary && this.searchCorpus.corpus[0] && this.searchCorpus.corpus[0].tfidf_vector;
            const hasConceptGroups = this.searchCorpus.concept_groups;
            
            let searchType = 'keyword-based';
            if (hasSemanticSearch && hasConceptGroups) {
                searchType = 'hybrid (keywords + TF-IDF + concepts)';
            } else if (hasSemanticSearch) {
                searchType = 'semantic (keywords + TF-IDF)';
            }
            
            // Show search status and sync inputs
            this.showSearchStatus(`Found ${results.length} trials using ${searchType} search for "${query}"`, 'success');
            this.syncSearchInputs(query);
            this.highlightSearchResults(results);
            
            // Generate LLM summary for significant results
            if (results.length >= 5 && results.length <= 50) {
                this.generateTrialSummary(query, results);
            }
            
            // Show floating search bar after highlighting
            if (!floatingMode) {
                setTimeout(() => this.showFloatingSearchBar(), 500);
            }
            
            // Log detailed results for debugging
            console.log(`üîç Top 5 results (${searchType}):`);
            results.slice(0, 5).forEach((result, i) => {
                console.log(`  ${i+1}. ${result.tpsId} (total: ${result.score.toFixed(1)}, keyword: ${result.keywordScore?.toFixed(1)}, semantic: ${result.semanticScore?.toFixed(1)}, concept: ${result.conceptScore?.toFixed(1)})`);
            });
        } else {
            this.showSearchStatus(`No trials found for "${query}". Try different terms.`, 'warning');
            this.clearSearchHighlights();
            this.hideFloatingSearchBar();
        }

        console.log('üìä Search results:', results.length, 'trials');
    }

    expandMedicalAbbreviations(query) {
        if (!this.searchCorpus?.abbreviations) return query;

        let expandedQuery = query;
        
        // Replace abbreviations with their expanded forms
        for (const [abbrev, expansions] of Object.entries(this.searchCorpus.abbreviations)) {
            const regex = new RegExp(`\\b${abbrev}\\b`, 'gi');
            if (regex.test(expandedQuery)) {
                // Add both the abbreviation and its expansions
                expandedQuery += ' ' + expansions.join(' ');
            }
        }

        return expandedQuery;
    }

    searchTrials(query) {
        if (!this.searchCorpus) return [];

        const queryTerms = query.toLowerCase().split(/\s+/).filter(term => term.length > 1);
        const results = new Map(); // Use Map to avoid duplicates and store scores

        // Check if we have TF-IDF vectors (hybrid corpus)
        const hasSemanticSearch = this.searchCorpus.vocabulary && this.searchCorpus.corpus[0] && this.searchCorpus.corpus[0].tfidf_vector;

        // Create query vector for semantic search
        let queryVector = null;
        if (hasSemanticSearch) {
            queryVector = this.createQueryVector(queryTerms);
        }

        // Search through each trial
        for (const item of this.searchCorpus.corpus) {
            let keywordScore = 0;
            let semanticScore = 0;
            
            const searchableText = item.searchable_text.toLowerCase();
            const keywords = item.keywords.map(k => k.toLowerCase());

            // 1. KEYWORD-BASED SCORING (as before)
            for (const term of queryTerms) {
                // Exact matches in keywords get highest score
                if (keywords.includes(term)) {
                    keywordScore += 10;
                }
                
                // Partial matches in keywords
                for (const keyword of keywords) {
                    if (keyword.includes(term) || term.includes(keyword)) {
                        keywordScore += 5;
                    }
                }

                // Matches in searchable text
                const termOccurrences = (searchableText.match(new RegExp(term, 'g')) || []).length;
                keywordScore += termOccurrences * 2;

                // Bonus for title matches
                const titlePart = searchableText.substring(0, 200);
                if (titlePart.includes(term)) {
                    keywordScore += 3;
                }
            }

            // 2. SEMANTIC SIMILARITY SCORING
            if (hasSemanticSearch && queryVector && item.tfidf_vector) {
                semanticScore = this.cosineSimilarity(queryVector, item.tfidf_vector) * 100;
            }

            // 3. CONCEPT GROUP MATCHING
            let conceptScore = 0;
            if (this.searchCorpus.concept_groups) {
                conceptScore = this.matchConceptGroups(query, item);
            }

            // 4. COMBINED SCORING
            // Weight: 60% keywords, 30% semantic, 10% concepts
            const totalScore = (keywordScore * 0.6) + (semanticScore * 0.3) + (conceptScore * 0.1);

            // Only include trials with positive scores
            if (totalScore > 0) {
                results.set(item.trial_index, {
                    trialIndex: item.trial_index,
                    tpsId: item.tps_id,
                    score: totalScore,
                    keywordScore: keywordScore,
                    semanticScore: semanticScore,
                    conceptScore: conceptScore
                });
            }
        }

        // Convert to array and sort by score
        return Array.from(results.values())
            .sort((a, b) => b.score - a.score)
            .slice(0, 50); // Limit to top 50 results
    }

    createQueryVector(queryTerms) {
        if (!this.searchCorpus.vocabulary) return null;

        const vector = new Array(this.searchCorpus.vocabulary.length).fill(0);
        const termCounts = {};
        
        // Count term frequencies in query
        for (const term of queryTerms) {
            termCounts[term] = (termCounts[term] || 0) + 1;
        }

        // Create TF vector for query
        for (const [term, count] of Object.entries(termCounts)) {
            const index = this.searchCorpus.vocabulary.indexOf(term);
            if (index !== -1) {
                // Simple TF weighting for query
                vector[index] = 1 + Math.log(count);
            }
        }

        return vector;
    }

    cosineSimilarity(vecA, vecB) {
        if (vecA.length !== vecB.length) return 0;

        let dotProduct = 0;
        let normA = 0;
        let normB = 0;

        for (let i = 0; i < vecA.length; i++) {
            dotProduct += vecA[i] * vecB[i];
            normA += vecA[i] * vecA[i];
            normB += vecB[i] * vecB[i];
        }

        if (normA === 0 || normB === 0) return 0;

        return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
    }

    matchConceptGroups(query, item) {
        if (!this.searchCorpus.concept_groups) return 0;

        let conceptScore = 0;
        const queryLower = query.toLowerCase();
        const itemText = item.searchable_text.toLowerCase();

        // Check each concept group
        for (const [groupName, concepts] of Object.entries(this.searchCorpus.concept_groups)) {
            let queryMatchesGroup = false;
            let itemMatchesGroup = false;

            // Check if query matches this concept group
            for (const concept of concepts) {
                if (queryLower.includes(concept.toLowerCase())) {
                    queryMatchesGroup = true;
                    break;
                }
            }

            // Check if item matches this concept group
            for (const concept of concepts) {
                if (itemText.includes(concept.toLowerCase())) {
                    itemMatchesGroup = true;
                    break;
                }
            }

            // Score if both query and item match the same concept group
            if (queryMatchesGroup && itemMatchesGroup) {
                conceptScore += 20;
            }
        }

        return conceptScore;
    }

    highlightSearchResults(results) {
        // Get search result TPS IDs
        const searchResultTpsIds = new Set(results.map(r => r.tpsId));
        
        // Only highlight search results that are also visible in current filtered data
        const visibleSearchResults = this.filteredData.filter(trial => searchResultTpsIds.has(trial.tpsId));
        const visibleSearchTpsIds = new Set(visibleSearchResults.map(trial => trial.tpsId));
        
        // Update chart with highlighting
        this.g.selectAll('.data-point')
            .classed('search-highlighted', d => visibleSearchTpsIds.has(d.tpsId))
            .classed('search-dimmed', d => !visibleSearchTpsIds.has(d.tpsId));
        
        console.log(`üîç Initial highlighting: ${visibleSearchResults.length} trials match search + current filters`);
    }

    clearSearchHighlights() {
        this.g.selectAll('.data-point')
            .classed('search-highlighted', false)
            .classed('search-dimmed', false);
    }

    updateSearchStatusWithFilters() {
        if (!this.activeSearch || this.searchResults.length === 0) return;

        // Count how many search results are currently visible after filtering
        const searchResultTpsIds = new Set(this.searchResults.map(r => r.tpsId));
        const visibleSearchResults = this.filteredData.filter(trial => searchResultTpsIds.has(trial.tpsId));
        
        // Get active filter descriptions
        const activeFilters = this.getActiveFilterDescriptions();
        
        // Determine search type
        const hasSemanticSearch = this.searchCorpus.vocabulary && this.searchCorpus.corpus[0] && this.searchCorpus.corpus[0].tfidf_vector;
        const hasConceptGroups = this.searchCorpus.concept_groups;
        
        let searchType = 'keyword-based';
        if (hasSemanticSearch && hasConceptGroups) {
            searchType = 'hybrid';
        } else if (hasSemanticSearch) {
            searchType = 'semantic';
        }

        // Create status message
        let message = `Found ${visibleSearchResults.length} trials using ${searchType} search for "${this.currentSearchQuery}"`;
        if (activeFilters.length > 0) {
            message += ` with filters: ${activeFilters.join(', ')}`;
        }
        
        this.showSearchStatus(message, 'success');
    }

    updateSearchHighlightingWithFilters() {
        if (!this.activeSearch || this.searchResults.length === 0) {
            this.clearSearchHighlights();
            return;
        }

        // Get search results that are also in filtered data
        const searchResultTpsIds = new Set(this.searchResults.map(r => r.tpsId));
        const visibleSearchResults = this.filteredData.filter(trial => searchResultTpsIds.has(trial.tpsId));
        const visibleSearchTpsIds = new Set(visibleSearchResults.map(trial => trial.tpsId));
        
        // If no search results match the current filters, clear highlighting
        if (visibleSearchResults.length === 0) {
            this.g.selectAll('.data-point')
                .classed('search-highlighted', false)
                .classed('search-dimmed', false);
            console.log(`üéØ No search results match current filters - cleared all highlighting`);
        } else {
            // Update chart with highlighting - only highlight points that match both search AND filters
            this.g.selectAll('.data-point')
                .classed('search-highlighted', d => visibleSearchTpsIds.has(d.tpsId))
                .classed('search-dimmed', d => !visibleSearchTpsIds.has(d.tpsId));
            console.log(`üéØ Updated highlighting: ${visibleSearchResults.length} trials match search + filters`);
        }
    }

    getActiveFilterDescriptions() {
        const filters = [];
        
        if (this.selectedTrack) {
            filters.push(`track: ${this.selectedTrack}`);
        }
        
        const populationFilter = document.getElementById('population-filter').value;
        if (populationFilter) {
            filters.push(`population: ${populationFilter}`);
        }
        
        const phaseFilter = document.getElementById('phase-filter').value;
        if (phaseFilter) {
            filters.push(`phase: ${phaseFilter}`);
        }
        
        const companyFilter = document.getElementById('company-filter').value;
        if (companyFilter) {
            filters.push(`company: ${companyFilter}`);
        }
        
        const trialFilter = document.getElementById('trial-filter').value;
        if (trialFilter) {
            filters.push(`trial: ${trialFilter}`);
        }
        
        const drugFilter = document.getElementById('drug-filter').value;
        if (drugFilter) {
            filters.push(`drug: ${drugFilter}`);
        }
        
        return filters;
    }

    async generateTrialSummary(query, results) {
        // Only proceed if we have a reasonable number of results
        if (results.length < 5) {
            console.log(`üß† Skipping LLM summary - too few results (${results.length} < 5)`);
            return;
        }

        try {
            console.log(`üß† Generating LLM summary for ${results.length} trials...`);
            
            // Test network connectivity first
            await this.testNetworkConnectivity();
            
            // Get trial data for top results
            const topResults = results.slice(0, 10);
            const trialData = topResults.map(r => {
                const trial = this.data.find(t => t.tpsId === r.tpsId);
                return {
                    title: trial?.title || '',
                    cancerType: trial?.cancerType || '',
                    drug: trial?.drug || '',
                    phase: trial?.trialPhase || '',
                    targetPopulation: trial?.targetPopulation || ''
                };
            });

            const prompt = `You are a clinical trial expert. Analyze these ${results.length} ASCO 2025 clinical trials found for the query "${query}" and provide a concise summary.

Top 10 trials:
${trialData.map((t, i) => 
    `${i+1}. ${t.title} | ${t.cancerType} | ${t.drug} | ${t.phase} | ${t.targetPopulation}`
).join('\n')}

Provide a 2-3 sentence summary highlighting:
- Main therapeutic approaches or drug classes
- Primary cancer types being studied  
- Notable patterns in trial phases or patient populations

Keep it concise and factual. Do not make clinical recommendations.`;

            const apiKey = this.getGroqApiKey();
            if (!apiKey) {
                console.log('üîë No Groq API key found, skipping LLM summary');
                console.log('üîë To configure: localStorage.setItem("ASCO_LLM_KEY", "your-groq-api-key")');
                return;
            }

            console.log('üîë API key found, making request to Groq...');
            console.log('üîó Request URL: https://api.groq.com/openai/v1/chat/completions');
            console.log('üîë API key (first 10 chars):', apiKey.substring(0, 10) + '...');
            
            const requestBody = {
                model: "gemma2-9b-it",
                messages: [{ role: "user", content: prompt }],
                temperature: 0.3,
                max_tokens: 200
            };
            console.log('üì§ Request body:', JSON.stringify(requestBody, null, 2));
            
            const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });
            
            console.log('üì° Response status:', response.status);
            console.log('üì° Response headers:', [...response.headers.entries()]);

            if (response.ok) {
                const data = await response.json();
                this.llmSummary = data.choices[0].message.content.trim();
                console.log('‚úÖ LLM summary generated:', this.llmSummary);
                
                // Trigger tooltip refresh if one is currently visible
                if (this.tooltip && this.tooltip.style("display") !== "none") {
                    console.log('üîÑ Refreshing visible tooltip with new LLM summary');
                }
            } else {
                const errorText = await response.text();
                console.error('‚ùå Groq API error:', response.status, response.statusText);
                console.error('‚ùå Error details:', errorText);
                this.llmSummary = `API Error (${response.status}): ${response.statusText}`;
            }
        } catch (error) {
            console.error('‚ùå Failed to generate LLM summary:', error);
            console.error('‚ùå Error type:', error.constructor.name);
            console.error('‚ùå Error stack:', error.stack);
            
            // Check for specific error types
            if (error.name === 'TypeError' && error.message.includes('fetch')) {
                this.llmSummary = `Network Error: Cannot reach Groq API. Check browser console for CORS/network issues.`;
            } else if (error.name === 'AbortError') {
                this.llmSummary = `Request Timeout: API request was cancelled.`;
            } else {
                this.llmSummary = `Error: ${error.message}`;
            }
        }
    }

    async testNetworkConnectivity() {
        try {
            console.log('üåê Testing network connectivity to Groq API...');
            
            // Test basic connectivity to Groq domain
            const testResponse = await fetch('https://api.groq.com/', {
                method: 'HEAD',
                mode: 'no-cors'
            });
            console.log('‚úÖ Basic connectivity to Groq API domain successful');
            
        } catch (error) {
            console.warn('‚ö†Ô∏è Network connectivity test failed:', error.message);
            console.warn('‚ö†Ô∏è This might indicate CORS, firewall, or network issues');
        }
    }

    getGroqApiKey() {
        // Use the indirection system for better security
        return window.API_CONFIG ? window.API_CONFIG.getApiKey() : null;
    }

    showFloatingSearchBar() {
        const floatingBar = document.getElementById('floating-search-bar');
        floatingBar.style.display = 'block';
        setTimeout(() => {
            floatingBar.classList.add('show');
        }, 10);
    }

    hideFloatingSearchBar() {
        const floatingBar = document.getElementById('floating-search-bar');
        floatingBar.classList.remove('show');
        setTimeout(() => {
            floatingBar.style.display = 'none';
        }, 300);
    }

    syncSearchInputs(query) {
        // Sync both search inputs
        document.getElementById('nl-query').value = query;
        document.getElementById('floating-nl-query').value = query;
    }

    clearSearch() {
        // Clear inputs
        document.getElementById('nl-query').value = '';
        document.getElementById('floating-nl-query').value = '';
        
        // Clear search state
        this.searchResults = [];
        this.activeSearch = false;
        this.currentSearchQuery = '';
        // Only clear LLM summary when explicitly clearing search, not when toggling UI
        this.llmSummary = null;
        
        // Clear highlights
        this.clearSearchHighlights();
        
        // Hide floating bar and status
        this.hideFloatingSearchBar();
        this.hideSearchStatus();
        
        console.log('üßπ Search cleared');
    }

    showSearchStatus(message, type = 'info') {
        // Update both status divs
        const statusDiv = document.getElementById('search-status');
        const floatingStatusDiv = document.getElementById('floating-search-status');
        
        statusDiv.textContent = message;
        statusDiv.className = `search-status ${type}`;
        statusDiv.style.display = 'block';
        
        floatingStatusDiv.textContent = message;
        floatingStatusDiv.className = `search-status ${type}`;
        floatingStatusDiv.style.display = 'block';
    }

    hideSearchStatus() {
        const statusDiv = document.getElementById('search-status');
        const floatingStatusDiv = document.getElementById('floating-search-status');
        
        statusDiv.style.display = 'none';
        floatingStatusDiv.style.display = 'none';
    }

    // TPS ID Search Methods
    setupTpsIdSearch() {
        const tpsSearchBtn = document.getElementById('tps-search-btn');
        const tpsClearBtn = document.getElementById('tps-clear-btn');
        const tpsQueryInput = document.getElementById('tps-query');
        const tpsToggleInput = document.getElementById('tps-search-toggle-input');
        const tpsSearchSection = document.querySelector('.tps-search-section');

        // Toggle functionality
        const handleTpsToggle = () => {
            const isTpsSearchVisible = tpsToggleInput.checked;
            const nlToggle = document.getElementById('search-toggle-input');
            
            if (isTpsSearchVisible) {
                // Show TPS search section
                tpsSearchSection.style.display = 'block';
                setTimeout(() => {
                    tpsSearchSection.classList.add('show');
                }, 10);
                
                // Disable natural language search toggle when TPS search is active
                nlToggle.disabled = true;
                nlToggle.checked = false;
                this.clearSearch();
                
                // Add visual feedback for disabled state
                const nlToggleContainer = nlToggle.closest('.search-toggle-container');
                nlToggleContainer.classList.add('disabled');
            } else {
                // Hide TPS search section
                tpsSearchSection.classList.remove('show');
                setTimeout(() => {
                    tpsSearchSection.style.display = 'none';
                }, 400);
                
                // Re-enable natural language search toggle when TPS search is turned off
                nlToggle.disabled = false;
                
                // Remove visual feedback for disabled state
                const nlToggleContainer = nlToggle.closest('.search-toggle-container');
                nlToggleContainer.classList.remove('disabled');
                
                // Clear TPS search when hiding
                this.clearTpsSearch();
            }
        };
        
        // Add event listener for toggle
        tpsToggleInput.addEventListener('change', (e) => {
            // Prevent toggle if disabled
            if (tpsToggleInput.disabled) {
                e.preventDefault();
                return false;
            }
            handleTpsToggle();
        });

        // Search button click
        tpsSearchBtn.addEventListener('click', () => {
            const query = tpsQueryInput.value.trim();
            if (query) {
                this.performTpsIdSearch(query);
            }
        });

        // Clear button click
        tpsClearBtn.addEventListener('click', () => {
            this.clearTpsSearch();
        });

        // Enter key in search input
        tpsQueryInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const query = tpsQueryInput.value.trim();
                if (query) {
                    this.performTpsIdSearch(query);
                }
            }
        });
    }

    performTpsIdSearch(query) {
        console.log('üéØ TPS ID Search for:', query);
        
        // Normalize the query - add TPS prefix if not present
        let tpsId = query.toUpperCase();
        if (!tpsId.startsWith('TPS')) {
            tpsId = 'TPS' + query;
        }
        
        // Find the trial
        const trial = this.data.find(t => t.tpsId === tpsId);
        
        if (trial) {
            // Valid TPS ID found
            this.tpsSearchActive = true;
            this.currentTpsSearchId = tpsId;
            
            // Show success status
            this.showTpsSearchStatus(`Found trial: ${tpsId} - ${trial.title}`, 'success');
            
            // Highlight the specific trial
            this.highlightTpsResult(trial);
            
            console.log('‚úÖ Found trial:', trial);
        } else {
            // Invalid TPS ID
            this.showTpsSearchStatus('Not a valid TPS abstract id in my db', 'error');
            this.clearTpsHighlights();
            
            console.log('‚ùå TPS ID not found:', tpsId);
        }
    }

    highlightTpsResult(trial) {
        // Clear any existing search highlights
        this.clearSearchHighlights();
        
        // Update filteredData to show only the found trial
        this.filteredData = [trial];
        
        // Update the chart to show only this single trial
        this.updateChart();
        
        console.log(`üéØ Showing only TPS: ${trial.tpsId}`);
    }

    clearTpsHighlights() {
        this.g.selectAll('.data-point')
            .classed('tps-highlighted', false)
            .classed('tps-dimmed', false);
    }

    clearTpsSearch() {
        // Clear input
        document.getElementById('tps-query').value = '';
        
        // Clear search state
        this.tpsSearchActive = false;
        this.currentTpsSearchId = '';
        
        // Restore filtered data to show all trials matching current filters
        this.applyFilters();
        
        // Clear highlights
        this.clearTpsHighlights();
        
        // Hide status
        this.hideTpsSearchStatus();
        
        console.log('üßπ TPS search cleared - restored all filtered data');
    }

    showTpsSearchStatus(message, type = 'info') {
        const statusDiv = document.getElementById('tps-search-status');
        statusDiv.textContent = message;
        statusDiv.className = `search-status ${type}`;
        statusDiv.style.display = 'block';
    }

    hideTpsSearchStatus() {
        const statusDiv = document.getElementById('tps-search-status');
        statusDiv.style.display = 'none';
    }
}

// Debugging function for response metrics extraction
window.testResponseExtraction = function() {
    if (!window.dashboard) {
        console.error('Dashboard not initialized yet');
        return;
    }
    
    console.log('üîç Testing response metrics extraction...');
    let totalTrials = 0;
    let trialsWithMetrics = 0;
    
    window.dashboard.data.forEach((trial, index) => {
        const metrics = window.dashboard.extractResponseMetrics(trial);
        totalTrials++;
        
        if (metrics.length > 0) {
            trialsWithMetrics++;
            console.log(`‚úÖ ${trial.tpsId}: Found ${metrics.length} response metrics`);
            metrics.forEach(metric => {
                console.log(`   üìä Response Data (${metric.metricName}): ${metric.value}`);
            });
        }
        
        // Only show first 10 for debugging
        if (index < 10 && metrics.length === 0) {
            console.log(`‚ùå ${trial.tpsId}: No response metrics found`);
        }
    });
    
    console.log(`üìà Summary: ${trialsWithMetrics}/${totalTrials} trials (${(trialsWithMetrics/totalTrials*100).toFixed(1)}%) have response data`);
    return { totalTrials, trialsWithMetrics, percentage: trialsWithMetrics/totalTrials*100 };
};

// Debugging function for manual API testing
window.testGroqAPI = async function() {
    const apiKey = window.API_CONFIG ? window.API_CONFIG.getApiKey() : null;
    
    if (!apiKey) {
        console.error('üîë No API key found. Set it with: localStorage.setItem("ASCO_LLM_KEY", "your-groq-api-key")');
        return;
    }
    
    console.log('üß™ Testing Groq API manually...');
    console.log('üîë API key (first 10 chars):', apiKey.substring(0, 10) + '...');
    
    const testRequest = {
        model: "gemma2-9b-it",
        messages: [{ role: "user", content: "Say hello!" }],
        temperature: 0.3,
        max_tokens: 50
    };
    
    try {
        console.log('üì§ Sending test request to Groq...');
        const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(testRequest)
        });
        
        console.log('üì° Response status:', response.status);
        console.log('üì° Response ok:', response.ok);
        
        if (response.ok) {
            const data = await response.json();
            console.log('‚úÖ API test successful!');
            console.log('üí¨ Response:', data.choices[0].message.content);
            return data;
        } else {
            const errorText = await response.text();
            console.error('‚ùå API test failed:', response.status, response.statusText);
            console.error('‚ùå Error details:', errorText);
            return { error: true, status: response.status, message: errorText };
        }
    } catch (error) {
        console.error('‚ùå Network error during API test:', error);
        return { error: true, message: error.message, type: error.constructor.name };
    }
};

// Initialize dashboard when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    try {
        console.log('DOM loaded, checking ascoTrialData:', typeof ascoTrialData, ascoTrialData ? ascoTrialData.length : 'undefined');
        const dashboard = new ASCOTrialDashboard();
        window.dashboard = dashboard;
        console.log('ASCO Dashboard initialized successfully');
        console.log('üß™ To test Groq API manually, run: testGroqAPI()');
        console.log('üìä To test response metrics extraction, run: testResponseExtraction()');
    } catch (error) {
        console.error('Error creating dashboard:', error);
        console.error('Error details:', error.stack);
    }
});

window.addEventListener('resize', function() {
    clearTimeout(window.resizeTimeout);
    window.resizeTimeout = setTimeout(() => {
        if (window.dashboard) {
            window.dashboard.createChart();
        }
    }, 250);
});
    </script>
</body>
</html>